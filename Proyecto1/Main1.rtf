{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww25400\viewh13480\viewkind0
\deftab720
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720

\f0\fs22 \cf0 \expnd0\expndtw0\kerning0
#include "ros/ros.h"\
#include "geometry_msgs/Twist.h"\
#include "turtlesim/Pose.h"\
#include <sstream>\
#include <turtlesim/Spawn.h>\
\
using namespace std;\
\
ros::Publisher velocity_publisher;\
ros::Subscriber pose_subscriber;// Esto nos sirve para declarar la position de la tortuga, lo usamos en setOrientacion\
turtlesim::Pose turtlesim_pose;\
\
const double PI = 3.14159265359;\
\
double gradosaRadianes(double angulo);\
double setOrientacion(double anguloDeseado);//esto gira la tortuga al \'e1ngulo que deseamos\
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message);//mensaje publicado cada vez que se mueve la tortuga.\
void moveraLugar(turtlesim::Pose poseFinal, double tolerancia, double z);//mueve a la tortuga a donde queremos\
double getDistancia(double x1, double y1, double x2, double y2);\
\
\
int main(int a1, char **a2)\
\{\
	ros::init(a1, a2, "turtlesim_cleaner");\
	ros::NodeHandle n;\
	double velocidad, velocidadAngular;\
	double distancia, angulo1, posX, posY;\
	bool seguir;\
	double z, ang;\
\
	velocity_publisher = n.advertise<geometry_msgs::Twist>("/turtle1/cmd_vel", 1000);\
	pose_subscriber = n.subscribe("/turtle1/pose", 10, poseCallback);\
	ros::Rate loop_rate(10); //Define la frecuencia de los mensajes.\
\
	ROS_INFO("\\n\\n\\n ********Proyecto 1.*********\\n\'94);\
	ROS_INFO("\\n\\n\\n ********Por favor teclea la informaci\'f3n que se te pide*********\\n\'94);\
	seguir = true;\
	while(seguir)\{\
	//Permite seguir la trayectoria que nos indique el usuario.**************\
	cout<<\'93Define la posici\'f3n en X: ";\
	cin>>posX;\
	cout<<\'93Define la posici\'f3n en Y: ";\
	cin>>posY;\
	cout<<"Tiempo en el que deseas llegar: ";\
	cin>>z;\
	cout<<\'93POSE (\'c1ngulo) final: ";\
        cin>>ang;\
\
	turtlesim::Pose poseFinal;\
	poseFinal.x = posX;\
	poseFinal.y = posY;\
	poseFinal.theta = 15;\
	moveraLugar(poseFinal, 1, z);\
	setOrientacion(gradosaRadianes(ang));\
\
	cout<<"\'bfQuieres moverte de nuevo? ingresa 1, en caso contrario ingresa 0\'94;\
        cin>>seguir;\
\
	\}\
	loop_rate.sleep();\
\
        ros::spin();\
\
        return 0;\
\
\}\
\
double gradosaRadianes(double angulo)\{\
	return angulo *PI /180.0;\
\}\
void rotate (double velocidadAngular, double anguloRelativo, bool clockwise)\{\
\
	geometry_msgs::Twist vel_msg;\
	   //set velocidad random en x\
	   vel_msg.linear.x =0;\
	   vel_msg.linear.y =0;\
	   vel_msg.linear.z =0;\
	   //set velocidad random en y \
	   vel_msg.angular.x = 0;\
	   vel_msg.angular.y = 0;\
	   if (clockwise)\
	   	vel_msg.angular.z =-abs(angular_speed);\
	   else\
	   	vel_msg.angular.z =abs(angular_speed);\
\
	   double t0 = ros::Time::now().toSec();\
	   double current_angle = 0.0;\
	   ros::Rate loop_rate(1000);\
	   do\{\
		   velocity_publisher.publish(vel_msg);\
		   double t1 = ros::Time::now().toSec();\
		   current_angle = velocidadAngular* (t1-t0);\
		   ros::spinOnce();\
		   loop_rate.sleep();\
		   //cout<<(t1-t0)<<", "<<current_angle <<", "<<anguloRelativo<<endl;\
	   \}while(current_angle<relative_angle);\
	   vel_msg.angular.z =0;\
	   velocity_publisher.publish(vel_msg);\
\}\
double setOrientacion(double anguloDeseado)\
\{	\
	double radianesRelativos = anguloDeseado - turtlesim_pose.theta;\
	bool clockwise = ((radianesRelativos<0)?true:false);\
	//cout<<anguloDeseado <<","<<turtlesim_pose.theta<<","<<radianesRelativos<<","<<clockwise<<endl;\
	rotate (abs(radianesRelativos), abs(radianesRelativos), clockwise);\
\}\
\
void poseCallback(const turtlesim::Pose::ConstPtr & pose_message)\{\
	turtlesim_pose.x=pose_message->x;\
	turtlesim_pose.y=pose_message->y;\
	turtlesim_pose.theta=pose_message->theta;\
\}\
\
\
void moveraLugar(turtlesim::Pose poseFinal, double tolerancia, double z)\{\
	geometry_msgs::Twist vel_msg;\
	double k=1.75;\
\
	ros::Rate loop_rate(10);\
	do\{\
		//linear velocity \
		vel_msg.linear.x =k*((getDistancia(turtlesim_pose.x, turtlesim_pose.y, poseFinal.x, poseFinal.y))/z);\
		vel_msg.linear.y = 0;\
		vel_msg.linear.z = 0;\
		//velocidad angular\
		vel_msg.angular.x = 0;\
		vel_msg.angular.y = 0;\
		vel_msg.angular.z = 4*(atan2(goal_pose.y - turtlesim_pose.y, poseFinal.x - turtlesim_pose.x)-turtlesim_pose.theta);\
\
		velocity_publisher.publish(vel_msg);\
\
		ros::spinOnce();\
		loop_rate.sleep();\
\
	\}while(getDistancia(turtlesim_pose.x, turtlesim_pose.y, poseFinal.x, poseFinal.y)>tolerancia);\
	cout<<"end move goal"<<endl;\
	vel_msg.linear.x = 0;\
	vel_msg.angular.z = 0;\
	velocity_publisher.publish(vel_msg);\
\
\}\
\
double getDistancia(double x1, double y1, double x2, double y2)\{\
	return sqrt(pow((x2-x1),2) + pow((y2-y1),2));\
\}\
}